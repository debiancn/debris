#!/usr/bin/env python3

"""debris-start -- trigger for debris debian package autobuild system."""

import argparse

import debris
import debris.db
import debris.git
import debris.sbuild
import debris.common

from debris.common import log, flags, getconfig
from debris.common import DebrisGlobalLock

my_builder = None

def firstrun():
    """Debris first-run wizard."""
    print('not implemented yet.')
    pass

def main():
    """Main function wrapper."""

    parser = argparse.ArgumentParser(
            description="debris-start trigger.",
            epilog="should be triggered using crontab."
            )
    parser.add_argument(
            '--firstrun',
            help="call the firstrun wizard",
            action="store_true",
            )
    parser.add_argument(
            '--config',
            '-c',
            help="run program with given config file"
            )
    parser.add_argument(
            '--version',
            '-V',
            help="show program version",
            action="version",
            version="debris-start 0.0.0",
            )
    parser.add_argument(
            '--verbose',
            '-v',
            help="increase verbose level",
            action="count",
            )
    parser.add_argument(
            '--quiet',
            '-q',
            help="decrease verbose level",
            action="count",
            )
    parser.add_argument(
            '--update-base-chroot',
            help="also update base chroots when preparing",
            action="store_true",
            )
    parser.add_argument(
            '--update-git-repo',
            help="update git repo and its submodule when preparing",
            action="store_true",
            )
    args = parser.parse_args()

    "calcuate verbosity first."
    log.setLevel(debris.common.get_log_verbosity((args.verbose or 0) - (args.quiet or 0)))
    log.debug("log verbosity set.")

    "then parse the arguments."
    if args.firstrun:
        firstrun()
        return
    if args.config:
        log.info('loading config file: {}'.format(str(args.config)))
        debris.common.load_config(args.config)
    if args.update_git_repo:
        debris.common.flags['UPDATE_GIT_REPO'] = True

    "Now, we really start the working instance."

    "Holding a global lock to prevent multiple instances from running."
    try:
        with DebrisGlobalLock():
            log.info('we got the global instance lock.')

            global my_builder
            my_builder = debris.sbuild.SBuilder()
            if args.update_base_chroot:
                my_builder.prepare()

            "the object that represent the repo"
            my_git_repo = debris.git.DebrisRepo(getconfig('DEBRIS_GIT_REPO_LOCAL'))

            "the object that represent the db"
            my_db = debris.db.DebrisDB(getconfig('DEBRIS_DB_FILE'))
            todo_pkglist = my_git_repo.get_todo_pkglist(
                    my_db.get_builtlist()
                    )

            "convert and build: git repo -> dsc -> result"
# XXX: WE SHOULD CONSIDER USING A QUEUE TO ARRANGE ALL WORKS!
            with debris.git.ClonedRepoContext(my_git_repo, todo_pkglist) as gcontext:
                log.debug("Good! we have context: {}".format(gcontext.path))
                __import__("time").sleep(3600)
                pass


    except DebrisGlobalLock.DebrisInstanceLockedError as e:
        raise


if __name__ == "__main__":
    main()
# FIXME: set global lock to prevent multiple instances
# FIXME: wrap the schroot loading into a function
# TODO: load schroot configuration
    pass
# TODO: update schroot
    pass
# FIXME: wrap the git parsing into a function
# TODO: find the local git repository and do cleanup / init
    pass
# TODO: update local git repository and submodules
    pass
# TODO: compare local repo and db info; filter packages to build
# FIXME: wrap the building part into a function
# TODO: generate the git-wanna-build list
    pass
# TODO: generate source package and .dsc description file
    pass
# TODO: build packages using .dsc; put the result in the given path
    pass
# TODO: post-build checks
    pass
# TODO: record build log; generate the build report; send out report
    pass
# FIXME: wrap the reprepro handler into a function
# TODO: let reprepro checkin the given src packages and deb packages
    pass
# TODO: generate the check-in report; send out report
    pass
# FIXME: release global lock on exit (context?)
